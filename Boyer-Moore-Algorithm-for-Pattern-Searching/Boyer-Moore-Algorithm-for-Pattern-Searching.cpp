//Реализовать алгоритм Бойера-Мура для поиска по образцу

/*
* /Шаг 1
Прикладываем левый край образца к левому краю текста,
К = 0
Заполняем таблицу сдвигов по стоп-символам d
 /Шаг 2
Проверяем, входит ли образец в текст, начиная с К-й
позиции, последовательным сравнением символов образца
q[j] с символами текста s[K+j] справа налево, j=M-1...0
 /Шаг 3
Если имеем M совпадений, то образец в тексте найден –
конец работы
Если K+M >= N, то образец в тексте не найден – конец
работы
Иначе K = K+d[s[K+M-1]] и переходим к шагу 2
*/

#include <iostream>
using namespace std;
#define NO_OF_CHARS 256

//тот самый плохой символ
void badCharHeuristic(string str, int size, int badchar[NO_OF_CHARS])
{
    int i;

    //делаем все -1
    for (i = 0; i < NO_OF_CHARS; i++)
        badchar[i] = -1;

    //заполянем действительным значением знака
    for (i = 0; i < size; i++)
        badchar[(int) str[i]] = i;
}

//функция поиска с помощью плохого символа
void search(string txt, string pat)
{    
    int m = pat.size();
    int n = txt.size();

    int badchar[NO_OF_CHARS];

    //заполянем массив плохих символов вызвов функции для данного образца
    badCharHeuristic(pat, m, badchar);

    int s = 0;// s - сдвиг 

    //уменьшаем j пока все символы образца и текста не сходятся по сдвигу
    while (s <= (n - m))
    {
        int j = m - 1;

        while (j >= 0 && pat[j] == txt[s + j])
        {
            j--;
        }

        if (j < 0)
        {
            cout << "shift at " << s << endl;
            //Сдвигаем образец так, чтобы следующий символ в тексте совпадал с последним его вхождением в образец.
            s += (s + m < n) ? m - badchar[txt[s + m]] : 1;
        }
        else
            //Сдвигаем образец так, чтобы плохой символ в тексте совпадал с последним его вхождением в образец.
            s += max(1, j - badchar[txt[s + j]]);
    }
}
int main()
{    
    string txt = "ABAAABCD";
    string pat = "ABC";
    search(txt,pat);
    return 0;
}

